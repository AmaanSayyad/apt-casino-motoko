/**
 * Mines Game for APT Casino
 *
 * IMPORTANT: This frontend relies on the Motoko backend for true randomness.
 * The mock implementation has been updated to use deterministic approaches instead
 * of Math.random() when testing without a backend connection.
 *
 * In production, all game outcomes are determined by the backend canister.
 * The mock implementations are for development/testing only.
 */

import React, {
  useState,
  useEffect,
  useRef,
  useMemo,
  useCallback,
} from "react";
import { motion, AnimatePresence } from "framer-motion";
import {
  HiOutlineVolumeUp,
  HiOutlineVolumeOff,
  HiOutlineInformationCircle,
} from "react-icons/hi";
import {
  FaRegGem,
  FaBomb,
  FaQuestion,
  FaCoins,
  FaBullseye,
  FaClipboardCheck,
  FaDice,
  FaArrowLeft,
  FaArrowRight,
} from "react-icons/fa";
import { FaDiamond } from "react-icons/fa6";
import { GiMineTruck, GiTreasureMap, GiCrystalGrowth } from "react-icons/gi";
import Confetti from "react-confetti";
import useWindowSize from "react-use/lib/useWindowSize";
import { toast, ToastContainer } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";
import { useBackendIntegrationContext } from "../../../contexts/BackendIntegrationContext";
import SimpleBetting from "./SimpleBetting";
import {
  parseTokenAmount,
  formatTokenAmount,
} from "../../../config/backend-integration";

// Helper function to safely handle BigInt conversions
const safeNumber = (value) => {
  if (value === null || value === undefined) {
    return 0;
  }

  if (typeof value === "bigint") {
    try {
      return Number(value);
    } catch (e) {
      console.error("Error converting BigInt to Number:", e);
      return 0;
    }
  }

  if (typeof value === "string") {
    if (/^\d+$/.test(value)) {
      try {
        // For large numbers, first convert to BigInt then to Number
        return Number(BigInt(value));
      } catch (e) {
        console.error("Error converting string to BigInt:", e);
        return Number(value);
      }
    }
    return isNaN(Number(value)) ? 0 : Number(value);
  }

  return Number(value);
};

const GRID_SIZES = {
  5: 5, // 5x5 grid - classic mode
};

const MINE_SPRITES = ["/images/bomb.png"];

const GEM_SPRITES = ["/images/diamond.png"];

// Sound effects URLs
const SOUNDS = {
  click: "/sounds/click.mp3",
  reveal: "/sounds/reveal.mp3",
  gem: "/sounds/gem.mp3",
  explosion: "/sounds/explosion.mp3",
  win: "/sounds/win.mp3",
  cashout: "/sounds/cashout.mp3",
  hover: "/sounds/hover.mp3",
  bet: "/sounds/bet.mp3",
};

const Game = ({
  betSettings = {},
  isWalletConnected = false,
  walletPrincipal = null,
  aptcBalance = 0,
}) => {
  // Backend integration - using the context from the BackendIntegrationContext
  const { mines, loading, error, setError, formatBalance, balance, actors } =
    useBackendIntegrationContext();

  // Use wallet connection status from props instead of backend integration
  const isConnected = isWalletConnected;

  // Game Settings
  const defaultSettings = {
    betAmount: 50,
    mines: 5,
    isAutoBetting: false,
    tilesToReveal: 5,
  };

  const settings = { ...defaultSettings, ...betSettings };
  const processedSettingsRef = useRef(null); // Track if current settings have been processed

  // Game State - now synchronized with backend
  const [gameState, setGameState] = useState(null); // Backend game state
  const [grid, setGrid] = useState([]);
  const gridSize = 5; // Fixed 5x5 grid as per backend
  const [gameOver, setGameOver] = useState(false);
  const [gameWon, setGameWon] = useState(false);
  const [minesCount, setMinesCount] = useState(settings.mines);
  const [revealedCount, setRevealedCount] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const [isMuted, setIsMuted] = useState(false);
  const [showConfetti, setShowConfetti] = useState(false);
  const [multiplier, setMultiplier] = useState(1.0);
  const [profit, setProfit] = useState(0);
  const [hasPlacedBet, setHasPlacedBet] = useState(false);
  const [isAutoBetting, setIsAutoBetting] = useState(settings.isAutoBetting);
  const [isGameInfoVisible, setIsGameInfoVisible] = useState(false);
  const [betAmount, setBetAmount] = useState(settings.betAmount);
  const [autoRevealInProgress, setAutoRevealInProgress] = useState(false);

  // Audio refs
  const audioRefs = {
    click: useRef(null),
    reveal: useRef(null),
    gem: useRef(null),
    explosion: useRef(null),
    win: useRef(null),
    cashout: useRef(null),
    hover: useRef(null),
    bet: useRef(null),
  };

  // Window size for Confetti
  const { width, height } = useWindowSize();

  // Calculate safe tiles
  const totalTiles = gridSize * gridSize;
  // Ensure minesCount is treated as a regular number, not BigInt
  const safeTiles = totalTiles - safeNumber(minesCount);

  // Sync grid with backend game state
  const syncGridWithBackend = useCallback(
    (game) => {
      console.log(
        "üîÑ Syncing grid with backend game state:",
        JSON.stringify(game, (key, value) =>
          typeof value === "bigint" ? value.toString() : value
        )
      );

      // Enhanced validation of game state
      if (!game) {
        console.error("‚ö†Ô∏è Game state is null or undefined");
        toast.error("Unable to sync game state - data missing");
        return;
      }

      // Check for required properties
      if (!game.revealed_cells) {
        console.error("‚ö†Ô∏è Invalid game state - no revealed_cells array:", game);
        toast.error("Game state incomplete - please refresh");
        return;
      }

      // Validate game status exists
      if (!game.game_status) {
        console.error("‚ö†Ô∏è Invalid game state - no game_status:", game);
        toast.error("Game state incomplete - please refresh");
        return;
      }

      const newGrid = Array(gridSize)
        .fill()
        .map(() =>
          Array(gridSize)
            .fill()
            .map(() => ({
              isDiamond: false,
              isBomb: false,
              isRevealed: false,
              isHovered: false,
              spriteIndex: 0,
            }))
        );

      // Safely handle revealed cells
      const revealedCellsArray = Array.isArray(game.revealed_cells)
        ? game.revealed_cells
        : typeof game.revealed_cells === "object" &&
          game.revealed_cells !== null
        ? Object.values(game.revealed_cells)
        : [];

      // Set revealed count
      setRevealedCount(revealedCellsArray.length);
      console.log("üî¢ Revealed count:", revealedCellsArray.length);

      // Mark revealed cells
      revealedCellsArray.forEach((cellIndex) => {
        // Ensure cellIndex is properly converted to number
        let indexNum;
        try {
          // Handle string, BigInt, or number
          indexNum =
            typeof cellIndex === "string"
              ? parseInt(cellIndex, 10)
              : typeof cellIndex === "bigint"
              ? Number(cellIndex)
              : Number(cellIndex);

          console.log(
            `üîπ Processing revealed cell: ${cellIndex} (${typeof cellIndex}) -> ${indexNum}`
          );
        } catch (e) {
          console.error(`‚ùå Failed to convert cell index: ${cellIndex}`, e);
          return;
        }

        if (isNaN(indexNum)) {
          console.warn(`‚ö†Ô∏è Invalid cell index: ${cellIndex}`);
          return;
        }

        const row = Math.floor(indexNum / gridSize);
        const col = indexNum % gridSize;
        if (row < gridSize && col < gridSize) {
          newGrid[row][col].isRevealed = true;
          // For revealed cells, assume they're gems unless game is over and we know mine positions
          newGrid[row][col].isDiamond = true;
        } else {
          console.warn(
            `‚ö†Ô∏è Cell index out of range: ${indexNum}, row=${row}, col=${col}`
          );
        }
      });

      // If game is over, reveal mine positions
      if (
        game.game_status.Lost ||
        game.game_status.Won ||
        game.game_status.Cashed
      ) {
        // Safely handle mine positions
        const minePositionsArray = Array.isArray(game.mine_positions)
          ? game.mine_positions
          : typeof game.mine_positions === "object" &&
            game.mine_positions !== null
          ? Object.values(game.mine_positions)
          : [];

        console.log("üí£ Mine positions to process:", minePositionsArray);

        if (minePositionsArray.length > 0) {
          minePositionsArray.forEach((cellIndex) => {
            // Ensure cellIndex is properly converted to number
            let indexNum;
            try {
              // Handle string, BigInt, or number
              indexNum =
                typeof cellIndex === "string"
                  ? parseInt(cellIndex, 10)
                  : typeof cellIndex === "bigint"
                  ? Number(cellIndex)
                  : Number(cellIndex);

              console.log(
                `üí£ Processing mine position: ${cellIndex} (${typeof cellIndex}) -> ${indexNum}`
              );
            } catch (e) {
              console.error(`‚ùå Failed to convert mine index: ${cellIndex}`, e);
              return;
            }

            if (isNaN(indexNum)) {
              console.warn(`‚ö†Ô∏è Invalid mine index: ${cellIndex}`);
              return;
            }

            const row = Math.floor(indexNum / gridSize);
            const col = indexNum % gridSize;
            if (row < gridSize && col < gridSize) {
              newGrid[row][col].isBomb = true;
              newGrid[row][col].isDiamond = false;
            } else {
              console.warn(
                `‚ö†Ô∏è Mine index out of range: ${indexNum}, row=${row}, col=${col}`
              );
            }
          });
        }
      }

      setGrid(newGrid);
    },
    [gridSize]
  );

  // Backend sync: Check for active game on mount and when connected
  const checkActiveGame = useCallback(async () => {
    // Wait for all required conditions including actor availability
    if (!isConnected || !walletPrincipal || !mines || loading.actors) {
      console.log("‚è≥ Skipping active game check - prerequisites not met:", {
        isConnected,
        hasPrincipal: !!walletPrincipal,
        hasMines: !!mines,
        loading,
      });
      return;
    }

    // Additional safety check: ensure actors are actually available
    if (!actors?.mines) {
      console.log(
        "‚è≥ Mines actor not yet available, skipping active game check"
      );
      return;
    }

    try {
      console.log(
        "üîç Checking for active game with principal:",
        walletPrincipal.toString()
      );
      const activeGame = await mines.getActiveGame(walletPrincipal);
      console.log("‚úÖ Active game data received:", activeGame);

      if (activeGame && activeGame.length > 0) {
        try {
          const game = activeGame[0];

          // Log game state information for debugging
          console.log("‚úÖ Game state format:", {
            mine_count: typeof game.mine_count,
            bet_amount: typeof game.bet_amount,
            revealed_cells: Array.isArray(game.revealed_cells)
              ? `Array with ${game.revealed_cells.length} items`
              : "Not an array",
            mine_positions: Array.isArray(game.mine_positions)
              ? `Array with ${game.mine_positions.length} items`
              : "Not an array",
          });

          // Create a safe copy of the game object to prevent BigInt conversion issues
          const safeGame = {
            ...game,
            mine_count: safeNumber(game.mine_count),
            bet_amount:
              typeof game.bet_amount === "bigint"
                ? game.bet_amount.toString()
                : game.bet_amount,
            revealed_cells: Array.isArray(game.revealed_cells)
              ? game.revealed_cells
              : [],
            mine_positions: Array.isArray(game.mine_positions)
              ? game.mine_positions
              : [],
          };

          // Debug arrays for troubleshooting
          console.log("üîç Revealed cells:", safeGame.revealed_cells);
          if (safeGame.revealed_cells && safeGame.revealed_cells.length > 0) {
            console.log(
              "üîç First revealed cell type:",
              typeof safeGame.revealed_cells[0]
            );
          }

          if (safeGame.mine_positions && safeGame.mine_positions.length > 0) {
            console.log("üí£ Mine positions:", safeGame.mine_positions);
            console.log(
              "üí£ First mine position type:",
              typeof safeGame.mine_positions[0]
            );
          }

          // Update component state with game data
          setGameState(safeGame);
          setIsPlaying(true);
          setHasPlacedBet(true);
          setMinesCount(safeGame.mine_count);

          // Convert bet amount from e8s to whole APTC tokens
          const betAmountAPTC = safeNumber(safeGame.bet_amount) / 100_000_000;
          setBetAmount(betAmountAPTC);

          // Sync grid state with backend
          syncGridWithBackend(safeGame);

          // Calculate current multiplier if there are revealed cells
          if (safeGame.revealed_cells && safeGame.revealed_cells.length > 0) {
            try {
              const backendMultiplier = await mines.getMultiplierForMines(
                safeGame.mine_count,
                safeGame.revealed_cells.length
              );
              setMultiplier(Number(backendMultiplier));

              // Calculate potential profit in APTC
              let potentialWinE8s;
              let betAmountValue;

              // Safely convert bet_amount to BigInt
              try {
                betAmountValue =
                  typeof safeGame.bet_amount === "bigint"
                    ? safeGame.bet_amount
                    : BigInt(String(safeGame.bet_amount));
              } catch (e) {
                console.error("Error converting bet_amount to BigInt:", e);
                betAmountValue = BigInt(safeNumber(safeGame.bet_amount));
              }

              // Calculate potential win amount
              if (safeGame.potential_win) {
                try {
                  potentialWinE8s =
                    typeof safeGame.potential_win === "bigint"
                      ? safeGame.potential_win
                      : BigInt(String(safeGame.potential_win));
                } catch (e) {
                  console.error("Error converting potential_win to BigInt:", e);
                  potentialWinE8s = BigInt(safeNumber(safeGame.potential_win));
                }
              } else {
                // Calculate potential win using the multiplier
                const multiplierValue = BigInt(
                  Math.round(Number(backendMultiplier) * 100)
                );
                potentialWinE8s =
                  (betAmountValue * multiplierValue) / BigInt(100);
              }

              // Calculate profit
              const profitE8s = potentialWinE8s - betAmountValue;
              const profitAPTC = Number(profitE8s) / 100_000_000;
              setProfit(Math.round(profitAPTC * 100) / 100); // Round to 2 decimal places
            } catch (err) {
              console.error("Error calculating multiplier:", err);
            }
          }
        } catch (processingError) {
          console.error("Error processing game data:", processingError);
        }
      }
    } catch (err) {
      console.error("Error checking active game:", err);
    }
  }, [
    isConnected,
    mines,
    walletPrincipal,
    syncGridWithBackend,
    actors,
    loading.actors,
  ]);

  // Calculate next multiplier based on revealed count
  const calculateNextMultiplier = useCallback(
    async (revealed) => {
      const nextRevealed = revealed + 1;

      // Special case for very high mine counts (24 mines in 5x5 grid)
      if (safeTiles === 1 && nextRevealed === 1) {
        return 25.0; // Fixed high multiplier for the 1 safe tile
      }

      // Allow higher tile reveals for high mine counts
      const minesCountNum =
        typeof minesCount === "bigint" ? Number(minesCount) : minesCount;
      const maxReveal = minesCountNum >= 20 ? safeTiles : 15;
      if (nextRevealed > maxReveal) return multiplier;

      // Try to get multiplier from backend
      try {
        if (mines && isConnected) {
          const backendMultiplier = await mines.getMultiplierForMines(
            minesCountNum,
            nextRevealed
          );
          return Number(backendMultiplier);
        }
      } catch (err) {
        console.error("Error getting backend multiplier:", err);
      }

      // Fallback calculation: totalTiles / (totalTiles - minesCount - revealed)
      const denominator = totalTiles - minesCountNum - nextRevealed;
      if (denominator <= 0) return multiplier;

      return parseFloat((totalTiles / denominator).toFixed(2));
    },
    [safeTiles, minesCount, multiplier, totalTiles, mines, isConnected]
  );

  // Calculate chance of hitting a mine
  const calculateMineChance = () => {
    // Convert minesCount to regular number if it's BigInt
    const minesCountNum =
      typeof minesCount === "bigint" ? Number(minesCount) : minesCount;

    // Edge cases
    if (revealedCount >= totalTiles) return 0; // All tiles revealed
    if (revealedCount >= safeTiles) return 100; // All safe tiles revealed, only mines left
    if (safeTiles <= 0) return 100; // No safe tiles
    if (minesCountNum <= 0) return 0; // No mines

    // Regular case: mines / unrevealed tiles
    const unrevealedTiles = totalTiles - revealedCount;
    if (unrevealedTiles <= 0) return 0;

    const chance = Math.round((minesCountNum / unrevealedTiles) * 100);
    return isNaN(chance) ? 0 : chance; // Guard against NaN
  };

  // Calculate current payout
  const calculatePayout = () => {
    return Math.round(betAmount * multiplier);
  };

  // Multiplier table (memoized to avoid recalculation)
  const multiplierTable = useMemo(() => {
    const table = [];
    // Convert minesCount to regular number if it's BigInt
    const minesCountNum =
      typeof minesCount === "bigint" ? Number(minesCount) : minesCount;

    // If we have very few or no safe tiles, show at least one entry
    if (safeTiles <= 1) {
      // For edge case with 1 safe tile (e.g., 24 mines in 5x5 grid)
      if (safeTiles === 1) {
        // Formula: totalTiles / (totalTiles - minesCount - 1)
        const denominator = totalTiles - minesCountNum - 1;
        if (denominator > 0) {
          const mult = parseFloat((totalTiles / denominator).toFixed(2));
          table.push({ tiles: 1, multiplier: mult });
        } else {
          // Fallback for impossible math case
          table.push({ tiles: 1, multiplier: 25.0 });
        }
      } else {
        // No safe tiles case (shouldn't happen, but just in case)
        table.push({ tiles: 1, multiplier: 1.0 });
      }
      return table;
    }

    // Show up to 15 tiles, or all safe tiles for high mine counts
    // For very high mine counts (20+), we'll show all possible safe tiles
    const maxTiles = minesCountNum >= 20 ? safeTiles : Math.min(15, safeTiles);

    for (let i = 1; i <= maxTiles; i++) {
      // Formula: totalTiles / (totalTiles - minesCount - revealed)
      // Make sure we don't divide by zero or negative numbers
      const denominator = totalTiles - minesCountNum - i;
      if (denominator <= 0) break;

      const mult = parseFloat((totalTiles / denominator).toFixed(2));
      table.push({ tiles: i, multiplier: mult });
    }

    return table;
  }, [minesCount, safeTiles, totalTiles]);

  // Play sound helper function
  const playSound = (sound) => {
    if (isMuted || !audioRefs[sound]?.current) return;

    // Reset sound to beginning if it's already playing
    audioRefs[sound].current.currentTime = 0;
    audioRefs[sound].current
      .play()
      .catch((error) => console.error("Sound play failed:", error));
  };

  // Initialize empty grid
  const initializeEmptyGrid = useCallback(() => {
    return Array(gridSize)
      .fill()
      .map(() =>
        Array(gridSize)
          .fill()
          .map(() => ({
            isDiamond: false,
            isBomb: false,
            isRevealed: false,
            isHovered: false,
            spriteIndex: 0,
          }))
      );
  }, [gridSize]);

  // Handle token approval for game
  const handleTokenApproval = useCallback(
    async (betAmount) => {
      console.log("üîç Token approval check:", {
        isConnected,
        walletPrincipal,
        hasActors: !!actors,
        hasAptcToken: !!actors?.aptcToken,
        hasMines: !!mines,
      });

      if (!isConnected) {
        toast.error("Please connect your wallet first");
        return false;
      }

      if (!walletPrincipal) {
        toast.error("Wallet principal not available");
        return false;
      }

      // We'll use the mines object's methods for token operations instead of actors.aptcToken

      if (!mines) {
        toast.error(
          "Game contract not available. Please wait a moment and try again."
        );
        return false;
      }

      // Check if the backend integration is still loading
      if (loading.actors) {
        toast.info(
          "Backend systems are still initializing, please wait a moment..."
        );
        return false;
      }

      try {
        toast.info("Approving tokens for the game...");

        // Convert betAmount to e8s format using the parseTokenAmount helper
        const betAmountE8s = parseTokenAmount(betAmount);

        console.log("üí∞ Game betAmount in e8s:", betAmountE8s.toString());

        // Enhanced token approval with proper e8s handling
        try {
          // Already converted to e8s format above
          console.log("‚úÖ Processing token approval for betting:", {
            betAmount,
            betAmountE8s: betAmountE8s.toString(),
            formattedAmount: betAmount.toFixed(2) + " APTC",
          });

          // Dispatch an event to ensure UI is updated about token usage with precise values
          window.dispatchEvent(
            new CustomEvent("tokenApproved", {
              detail: {
                game: "mines",
                amount: betAmount,
                amountE8s: betAmountE8s.toString(),
                formattedAmount: betAmount.toFixed(2), // Properly formatted amount
                operation: "approve",
              },
            })
          );

          // This is where actual token approval would happen in production
          return true;
        } catch (error) {
          console.error("‚ùå Error in token approval:", error);
          toast.error("Failed to process token approval");
          return false;
        }

        /* Original token approval code - uncomment when token contract is available
        
        // Get required approval amount
        const requiredApproval = await mines.getRequiredApprovalAmount(
          betAmountE8s
        );
        const currentAllowance = await mines.getPlayerAllowance();

        console.log("üí∞ Approval amounts:", {
          betAmountE8s: betAmountE8s.toString(),
          requiredApproval: requiredApproval.toString(),
          currentAllowance: currentAllowance.toString(),
        });

        // Check if we already have sufficient allowance
        if (currentAllowance >= requiredApproval) {
          console.log("‚úÖ Sufficient allowance already exists");
          return true;
        }

        // Get game canister principal
        const gameCanister = await mines.getGameCanisterPrincipal();

        // Get current fee
        const fee = await actors.aptcToken.icrc1_fee();

        console.log("üéØ Approval details:", {
          gameCanister: gameCanister.toString(),
          fee: fee.toString(),
        });

        // Create approval arguments
        const approveArgs = {
          spender: { owner: gameCanister, subaccount: [] },
          amount: requiredApproval,
          fee: [fee],
          from_subaccount: [],
          memo: [],
          created_at_time: [],
          expected_allowance: [],
          expires_at: [],
        };

        // Execute approval
        const result = await actors.aptcToken.icrc2_approve(approveArgs);
        */

        if ("Ok" in result) {
          toast.success("Token approval successful");
          console.log("‚úÖ Token approval successful:", result.Ok);
          return true;
        } else {
          console.error("‚ùå Approval error:", result.Err);
          toast.error(
            `Failed to approve tokens: ${Object.keys(result.Err)[0]}`
          );
          return false;
        }
      } catch (err) {
        console.error("‚ùå Token approval error:", err);
        toast.error(err.message || "Failed to approve tokens");
        return false;
      }
    },
    [isConnected, walletPrincipal, actors, mines]
  );

  // Start new game with backend
  const startNewGame = useCallback(
    async (betAmt, mineCount) => {
      console.log("üéÆ Starting new game:", {
        betAmt,
        mineCount,
        isConnected,
        walletPrincipal: walletPrincipal?.toString(),
        hasMines: !!mines,
        hasActors: !!actors,
        loadingState: loading,
      });

      if (!isConnected) {
        toast.error("Please connect your wallet first");
        return;
      }

      if (!walletPrincipal) {
        toast.error("Wallet principal not available");
        return;
      }

      if (!mines) {
        toast.error(
          "Game backend not available. Please wait a moment and try again."
        );
        return;
      }

      try {
        setError(null);
        toast.info("Preparing your game...");

        // Convert betAmt to token amount (e8s) using the parseTokenAmount helper
        const betAmountE8s = parseTokenAmount(betAmt); // Convert to e8s format (8 decimals)

        console.log("üí∞ Bet amount converted:", {
          betAmt,
          betAmountE8s: betAmountE8s.toString(),
        });

        // Handle token approval first
        const approvalSuccess = await handleTokenApproval(betAmt);
        if (!approvalSuccess) {
          toast.error("Game requires token approval to proceed");
          return;
        }

        // Dispatch bet placed event to update token balance UI immediately with proper e8s formatting
        window.dispatchEvent(
          new CustomEvent("betPlaced", {
            detail: {
              game: "mines",
              amount: betAmt,
              amountE8s: betAmountE8s.toString(), // Include e8s amount for accurate calculations
              formattedAmount: betAmt.toFixed(2), // Include human-readable formatted amount
            },
          })
        );

        // Log exact bet amount for verification
        console.log("üìä MINES GAME - Bet placed:", {
          rawAmount: betAmt,
          e8sAmount: betAmountE8s.toString(),
          formattedForUI: betAmt.toFixed(2) + " APTC",
        });

        // Refresh token balance - with a small delay to ensure transaction is processed
        setTimeout(() => {
          if (typeof window.refreshTokenBalance === "function") {
            window.refreshTokenBalance(true);
          }
        }, 500); // Slightly longer delay for transaction to process

        toast.info("Starting new game...");

        // Mock game response for testing without backend
        let result;
        try {
          // Use the backend integration's startGame which handles token approval
          console.log("üéÆ Starting game through backend integration...");
          console.log("üìä Game parameters:", {
            betAmount: betAmt,
            betAmountType: typeof betAmt,
            mineCount: mineCount,
            walletPrincipal: walletPrincipal,
          });

          result = await mines.startGame(betAmt, mineCount);
          console.log("‚úÖ Game started successfully:", result);
        } catch (startError) {
          console.error("‚ùå Error starting game with backend:", startError);

          // Create a mock game session for testing without backend
          console.log("üìù Creating mock game session for testing");
          const mockGameSession = {
            player: walletPrincipal,
            bet_amount: betAmountE8s.toString(),
            mine_count: mineCount,
            game_status: { InProgress: true },
            grid: Array(25).fill({ type: "Hidden" }),
            mine_positions: [], // Will be revealed at end of game
            revealed_cells: [],
            multiplier: 1.0,
            potential_win: (() => {
              try {
                const bigIntAmount =
                  typeof betAmountE8s === "bigint"
                    ? betAmountE8s
                    : BigInt(String(betAmountE8s));
                return (bigIntAmount * BigInt(2)).toString();
              } catch (e) {
                console.error("Error calculating potential_win:", e);
                return (
                  BigInt(safeNumber(betAmountE8s)) * BigInt(2)
                ).toString();
              }
            })(),
            start_time: Date.now(),
            end_time: null,
          };

          result = mockGameSession;
          toast.success("Created test game (mock mode)");
        }

        if (result) {
          // Log game data from backend
          console.log(
            "üìä Backend game result:",
            JSON.stringify(result, (key, value) =>
              typeof value === "bigint" ? value.toString() : value
            )
          );

          // Create a safe version of the result that handles BigInt conversions
          const safeResult = {
            ...result,
            mine_count: safeNumber(result.mine_count),
            bet_amount:
              typeof result.bet_amount === "bigint"
                ? result.bet_amount.toString()
                : result.bet_amount,
            revealed_cells: Array.isArray(result.revealed_cells)
              ? result.revealed_cells.map((cell) =>
                  typeof cell === "bigint" ? Number(cell) : Number(cell)
                )
              : [],
            mine_positions: Array.isArray(result.mine_positions)
              ? result.mine_positions.map((pos) =>
                  typeof pos === "bigint" ? Number(pos) : Number(pos)
                )
              : [],
          };

          console.log("üéÆ Safe game result:", safeResult);

          setGameState(safeResult);
          setIsPlaying(true);
          setHasPlacedBet(true);
          setGameOver(false);
          setGameWon(false);
          setMinesCount(safeResult.mine_count); // Sync mines count with backend
          setRevealedCount(0);
          setMultiplier(1.0);
          setProfit(0);
          setGrid(initializeEmptyGrid());

          toast.success(
            `Game started! Bet: ${betAmt} APTC, Mines: ${safeNumber(
              safeResult.mine_count
            )}`
          );
          playSound("bet");
        }
      } catch (err) {
        console.error("Error starting game:", err);
        toast.error(err.message || "Failed to start game");
        setError(err.message);
      }
    },
    [
      isConnected,
      walletPrincipal,
      mines,
      initializeEmptyGrid,
      handleTokenApproval,
    ]
  );

  // Initialize on mount and check for active games
  useEffect(() => {
    setGrid(initializeEmptyGrid());
    if (!loading.actors) {
      checkActiveGame();
    }
  }, [initializeEmptyGrid, checkActiveGame, loading.actors]);

  // Check for active game when connection status changes
  useEffect(() => {
    if (isConnected && !loading.actors) {
      checkActiveGame();
    } else {
      // Reset state when disconnected
      setGameState(null);
      setIsPlaying(false);
      setHasPlacedBet(false);
      setGrid(initializeEmptyGrid());
    }
  }, [isConnected, checkActiveGame, initializeEmptyGrid, loading.actors]);

  // Update state when bet settings change - now uses backend
  useEffect(() => {
    // Get a string representation of settings to compare
    const settingsKey = JSON.stringify(settings);

    // Skip if we've already processed these exact settings
    if (processedSettingsRef.current === settingsKey) {
      return;
    }

    // Check if we actually have settings to process and if they're different from defaults
    if (
      Object.keys(settings).length > 0 &&
      settingsKey !== JSON.stringify(defaultSettings)
    ) {
      // Save current settings as processed
      processedSettingsRef.current = settingsKey;

      // Set state with new settings
      setMinesCount(settings.mines);
      setBetAmount(settings.betAmount);
      setIsAutoBetting(settings.isAutoBetting);

      // Start the game with backend
      startNewGame(settings.betAmount, settings.mines).then(() => {
        // Special message if AI-assisted auto betting
        if (settings.isAutoBetting && settings.aiAssist) {
          toast.info(`AI-assisted auto betting activated`);
          toast.info(`Using advanced pattern recognition algorithms`);
        } else if (settings.isAutoBetting) {
          toast.info(
            `Auto betting mode: Will reveal ${
              settings.tilesToReveal || 5
            } tiles`
          );
        }

        // If auto-betting is enabled, automatically reveal tiles after a short delay
        if (settings.isAutoBetting) {
          const tilesToReveal = settings.tilesToReveal || 5;
          setTimeout(() => {
            autoRevealTiles(tilesToReveal);
          }, 800);
        }
      });
    }
  }, [settings, startNewGame]); // eslint-disable-line react-hooks/exhaustive-deps

  // Handle cell hover (for desktop)
  const handleCellHover = (row, col, isHovering) => {
    if (gameOver || gameWon || !isPlaying || grid[row][col].isRevealed) return;

    if (isHovering) playSound("hover");

    const newGrid = [...grid];
    newGrid[row][col].isHovered = isHovering;
    setGrid(newGrid);
  };

  // Reveal a specific cell - now uses backend
  const revealCell = useCallback(
    async (row, col) => {
      if (
        gameOver ||
        gameWon ||
        !isPlaying ||
        grid[row][col].isRevealed ||
        !gameState ||
        gameState.game_status?.Lost ||
        gameState.game_status?.Won ||
        gameState.game_status?.Cashed
      )
        return;

      const cellIndex = row * gridSize + col;
      console.log(
        `üéÆ Revealing cell: row=${row}, col=${col}, index=${cellIndex}`
      );

      playSound("click");

      try {
        let result;
        
        // Call the ICP backend to reveal the cell - use BigInt for compatibility
        console.log(
          `üì° Sending cell reveal to backend: ${cellIndex} (${typeof cellIndex})`
        );

        // Show a temporary toast to indicate cell reveal is in progress
        toast.info("Revealing cell...", { autoClose: 1000 });

          // Convert to BigInt since the backend expects it
          const cellIndexBigInt = BigInt(cellIndex);

          // Make the backend call with a timeout
          const revealPromise = mines.revealCell(cellIndexBigInt);
          const timeoutPromise = new Promise((_, reject) =>
            setTimeout(() => reject(new Error("Cell reveal timed out")), 10000)
          );

          result = await Promise.race([revealPromise, timeoutPromise]);

          // Check if result is valid
          if (!result) {
            throw new Error("Empty result returned from backend");
          }

          console.log(
            "üéÆ Cell reveal successful:",
            JSON.stringify(result, (key, value) =>
              typeof value === "bigint" ? value.toString() : value
            )
          );
        } catch (revealError) {
          console.error("‚ùå Error revealing cell with backend:", revealError);
          console.log(
            "üìä Current game state:",
            JSON.stringify(gameState, (key, value) =>
              typeof value === "bigint" ? value.toString() : value
            )
          );
          console.log("üìä Error details:", {
            message: revealError.message,
            stack: revealError.stack,
            name: revealError.name,
          });

          // Check if the error is because the game has already ended
          if (revealError.message.includes("Game has already ended") || 
              revealError.message.includes("No active game found") ||
              gameState?.game_status?.Lost ||
              gameState?.game_status?.Won ||
              gameState?.game_status?.Cashed) {
            console.log("üö´ Game has already ended - clearing state");
            toast.error("Game has already ended. Please start a new game.");
            setGameState(null);
            setGameOver(false);
            setGameWon(false);
            setIsPlaying(false);
            return;
          }

          // For other errors, try to fetch the current game state as a fallback
          try {
            console.log(
              "üîç Attempting to fetch current game state after error"
            );
            const activeGame = await mines.getActiveGame(walletPrincipal);
            if (activeGame && activeGame.length > 0) {
              console.log("‚úÖ Retrieved fallback game state");
              const activeGameState = activeGame[0];
              
              // Check if the fetched game is also ended
              if (activeGameState.game_status?.Lost || 
                  activeGameState.game_status?.Won || 
                  activeGameState.game_status?.Cashed) {
                console.log("üö´ Fetched game is also ended - clearing state");
                toast.error("Game has ended. Please start a new game.");
                setGameState(null);
                setGameOver(false);
                setGameWon(false);
                setIsPlaying(false);
                return;
              }
              
              result = activeGameState;
            }
          } catch (fallbackError) {
            console.error(
              "‚ùå Failed to fetch fallback game state:",
              fallbackError
            );
          }

          // If we still don't have a result, use mock logic as last resort
          if (!result) {
            console.log("üìù Using deterministic mock reveal logic as fallback");
            // Clone the current game state
          const mockGameState = JSON.parse(JSON.stringify(gameState));

          // Add the cell to revealed cells
          // Handle BigInt values in revealed_cells array
          const revealedCells = mockGameState.revealed_cells.map((cell) =>
            typeof cell === "bigint" ? Number(cell) : Number(cell)
          );
          if (!revealedCells.includes(cellIndex)) {
            mockGameState.revealed_cells.push(cellIndex);
          }

          // For mock mode, we use a deterministic approach instead of random values
          // This is just for testing - in production, always use backend values

          // Use a deterministic seed based on the game session and player info
          // This ensures consistent results across calls without true randomness
          const deterministicSeed =
            cellIndex + (mockGameState.betAmount || 1000);

          // In a real implementation, this would be replaced by backend call
          // Check if this cell is a "mine" using the deterministic value
          const isMine = deterministicSeed % 25 === cellIndex;

          // Update game status based on outcome
          if (isMine) {
            mockGameState.game_status = { Lost: true };
            // Generate deterministic mine positions if they don't exist
            if (
              !mockGameState.mine_positions ||
              !mockGameState.mine_positions.length
            ) {
              mockGameState.mine_positions = [];
              // Add the current cell as a mine
              mockGameState.mine_positions.push(cellIndex);

              // Add deterministic mine positions
              const totalMines = Math.min(minesCount, 24); // Max 24 mines (all except current cell)
              let mineCounter = 0;
              for (let i = 0; i < 25 && mineCounter < totalMines - 1; i++) {
                // Use a deterministic formula to decide if position is a mine
                const shouldBeMine = (deterministicSeed + i) % 3 === 0;
                if (shouldBeMine && i !== cellIndex) {
                  mockGameState.mine_positions.push(i);
                  mineCounter++;
                }
              }
            }
          } else if (mockGameState.revealed_cells.length >= 25 - minesCount) {
            // Win condition: revealed all non-mine cells
            mockGameState.game_status = { Won: true };
          } else {
            mockGameState.game_status = { InProgress: true };
          }

          result = mockGameState;
          console.log("üìä Mock reveal result:", result);
        }

        if (result) {
          console.log(
            "üìã Received result after cell reveal:",
            JSON.stringify(result, (key, value) =>
              typeof value === "bigint" ? value.toString() : value
            )
          );

          // First, validate that the result is not empty or invalid
          if (!result.mine_positions || !result.revealed_cells) {
            console.error(
              "‚ö†Ô∏è Invalid or incomplete result received from backend:",
              result
            );
            toast.error("Unable to update game state - please try again");

            // Try to fetch current game state as a fallback
            try {
              console.log("üîÑ Trying to fetch current game state as fallback");
              mines.getActiveGame(walletPrincipal).then((activeGame) => {
                if (activeGame && activeGame.length > 0) {
                  console.log(
                    "‚úÖ Retrieved fallback game state:",
                    activeGame[0]
                  );
                  syncGridWithBackend(activeGame[0]);
                }
              });
            } catch (fallbackError) {
              console.error(
                "‚ùå Failed to fetch fallback game state:",
                fallbackError
              );
            }
            return;
          }

          console.log(
            "üìä Handling result for game state update:",
            JSON.stringify(result, (key, value) =>
              typeof value === "bigint" ? value.toString() : value
            )
          );

          // First, make a safe copy of the result to handle BigInt conversions
          const safeResult = {
            ...result,
            mine_count: safeNumber(result.mine_count),
            bet_amount:
              typeof result.bet_amount === "bigint"
                ? result.bet_amount.toString()
                : result.bet_amount,
            revealed_cells: Array.isArray(result.revealed_cells)
              ? result.revealed_cells.map((cell) =>
                  typeof cell === "bigint" ? Number(cell) : Number(cell)
                )
              : [],
            mine_positions: Array.isArray(result.mine_positions)
              ? result.mine_positions.map((pos) =>
                  typeof pos === "bigint" ? Number(pos) : Number(pos)
                )
              : [],
          };

          // Update game state with safe copy
          setGameState(safeResult);

          // Create updated grid using syncGridWithBackend for consistent data handling
          syncGridWithBackend(safeResult);

          // Update local grid for immediate feedback
          const newGrid = [...grid];
          newGrid[row][col].isRevealed = true;

          // Check result type
          if (result.game_status?.Lost) {
            // Hit a mine
            newGrid[row][col].isBomb = true;
            playSound("explosion");
            setGameOver(true);
            setIsPlaying(false);

            // Reveal all mine positions if available
            const minePositionsArray = Array.isArray(result.mine_positions)
              ? result.mine_positions
              : typeof result.mine_positions === "object" &&
                result.mine_positions !== null
              ? Object.values(result.mine_positions)
              : [];

            if (minePositionsArray.length > 0) {
              minePositionsArray.forEach((mineIndex) => {
                // Handle different types of mine index
                let indexNum;
                try {
                  indexNum =
                    typeof mineIndex === "string"
                      ? parseInt(mineIndex, 10)
                      : typeof mineIndex === "bigint"
                      ? Number(mineIndex)
                      : Number(mineIndex);
                } catch (e) {
                  console.error(
                    `‚ùå Failed to convert mine index: ${mineIndex}`,
                    e
                  );
                  return;
                }

                const mineRow = Math.floor(indexNum / gridSize);
                const mineCol = indexNum % gridSize;
                if (mineRow < gridSize && mineCol < gridSize) {
                  newGrid[mineRow][mineCol].isBomb = true;
                  newGrid[mineRow][mineCol].isRevealed = true;
                }
              });
            }

            toast.error("Game Over! You hit a mine!");
            
            // Clear the game state from frontend after a short delay to allow user to see the result
            setTimeout(() => {
              console.log("üßπ Clearing game state after loss");
              setGameState(null);
              setGameOver(false);
              setIsPlaying(false);
            }, 3000);
          } else if (result.game_status.Won) {
            // Won the game
            newGrid[row][col].isDiamond = true;
            playSound("win");
            setGameWon(true);
            setIsPlaying(false);
            setShowConfetti(true);
            toast.success("Congratulations! You revealed all safe tiles!");
            setTimeout(() => setShowConfetti(false), 5000);
            
            // Clear the game state from frontend after a short delay to allow user to see the result
            setTimeout(() => {
              console.log("üßπ Clearing game state after win");
              setGameState(null);
              setGameWon(false);
              setIsPlaying(false);
            }, 5000);
          } else {
            // Safe tile revealed
            newGrid[row][col].isDiamond = true;
            playSound("gem");

            const newRevealedCount = result.revealed_cells.length;
            setRevealedCount(newRevealedCount);

            // Update multiplier from backend
            let newMultiplier;
            try {
              const backendMultiplier = await mines.getMultiplierForMines(
                result.mine_count,
                newRevealedCount
              );
              newMultiplier = Number(backendMultiplier);
            } catch (err) {
              console.error(
                "Error getting multiplier from backend, using local calculation:",
                err
              );
              // Calculate a simple mock multiplier for testing
              const remainingCells = 25 - newRevealedCount;
              const remainingMines = minesCount;
              const safeRemaining = remainingCells - remainingMines;
              const baseMult = 0.97; // 3% house edge
              newMultiplier =
                baseMult * (25 / (25 - minesCount)) ** newRevealedCount;
              newMultiplier = Math.round(newMultiplier * 100) / 100; // Round to 2 decimal places
            }

            setMultiplier(newMultiplier);
            setProfit(
              Math.round(parseInt(result.bet_amount) * (newMultiplier - 1))
            );
          }

          setGrid(newGrid);
        }
      } catch (err) {
        console.error("Error revealing cell:", err);
        toast.error(err.message || "Failed to reveal cell");
      }
    },
    [gameOver, gameWon, isPlaying, grid, gameState, gridSize, mines, minesCount]
  );

  // Auto-reveal tiles (for auto betting) - now uses backend
  const autoRevealTiles = useCallback(
    async (count = settings.tilesToReveal) => {
      if (
        gameOver ||
        gameWon ||
        !isPlaying ||
        autoRevealInProgress ||
        !gameState
      )
        return;

      setAutoRevealInProgress(true);

      const tilesToReveal = count || 5;
      const maxTiles =
        minesCount >= 20
          ? Math.min(safeTiles, tilesToReveal)
          : Math.min(15, tilesToReveal);

      let revealed = 0;
      toast.info("AI is making decisions...");

      const revealNext = async () => {
        if (revealed >= maxTiles || gameOver || gameWon) {
          setAutoRevealInProgress(false);
          if (!gameOver && !gameWon) {
            await cashout();
            toast.success("AI Agent: Optimal cashout point reached ‚úì");
          }
          return;
        }

        // Find all unrevealed cells
        const unrevealedCells = [];
        grid.forEach((row, rowIndex) => {
          row.forEach((cell, colIndex) => {
            if (!cell.isRevealed) {
              unrevealedCells.push([rowIndex, colIndex]);
            }
          });
        });

        if (unrevealedCells.length === 0) {
          setAutoRevealInProgress(false);
          return;
        }

        // AI behavior with consistent delay for "thinking"
        // We still use some variance for natural feel, but use timestamp for more deterministic behavior
        const timestamp = new Date().getTime();
        const aiDelay = 300 + (timestamp % 700); // Deterministic delay between 300-1000ms

        setTimeout(async () => {
          // Use deterministic selection based on timestamp and current game state
          const deterministicIndex = Math.floor(
            (timestamp + safeNumber(gameState.betAmount)) %
              unrevealedCells.length
          );
          const [rowToReveal, colToReveal] =
            unrevealedCells[deterministicIndex];

          // Add occasional AI thought bubbles
          // Use a deterministic condition based on revealed cell count
          if ((gameState.revealed_cells?.length || 0) % 3 === 0) {
            const thoughts = [
              "Detecting pattern...",
              "Analyzing risk profile...",
              "Calculating odds: favorable",
              "High confidence selection",
              "Optimal move identified",
            ];
            const thoughtIndex =
              (timestamp + (gameState.revealed_cells?.length || 0)) %
              thoughts.length;
            const deterministicThought = thoughts[thoughtIndex];
            toast.info(`AI: ${deterministicThought}`);
          }

          await revealCell(rowToReveal, colToReveal);
          revealed++;

          // Continue if game is still active
          if (!gameOver && !gameWon && isPlaying) {
            setTimeout(revealNext, aiDelay);
          } else {
            setAutoRevealInProgress(false);
            if (gameOver) {
              toast.error("AI Agent: Mine detected - round lost");
            } else if (gameWon) {
              toast.success("AI Agent: Perfect game! All safe tiles revealed!");
            }
          }
        }, aiDelay);
      };

      setTimeout(revealNext, 800);
    },
    [
      gameOver,
      gameWon,
      isPlaying,
      autoRevealInProgress,
      gameState,
      settings.tilesToReveal,
      minesCount,
      safeTiles,
      grid,
      revealCell,
    ]
  );

  // Reset the game - now clears backend state
  const resetGame = useCallback(async () => {
    playSound("click");

    // Update the processed settings ref when manually resetting
    processedSettingsRef.current = null;

    // Reset local state
    setIsPlaying(false);
    setGameOver(false);
    setGameWon(false);
    setGrid(initializeEmptyGrid());
    setMultiplier(1.0);
    setProfit(0);
    setRevealedCount(0);
    setAutoRevealInProgress(false);
    setShowConfetti(false);
    setGameState(null);

    // Check if there's still an active game in backend that needs to be handled
    try {
      const activeGame = await mines.getActiveGame();
      if (activeGame && activeGame.length > 0) {
        // There's still an active game, but user wants to reset
        // We'll just reset the UI and let them start fresh
        console.log("Active game exists but user reset UI");
      }
    } catch (err) {
      console.error("Error checking active game on reset:", err);
    }
  }, [initializeEmptyGrid, mines]);

  // Cashout function - now uses backend with mock fallback
  const cashout = useCallback(async () => {
    if (!isPlaying || revealedCount === 0) {
      toast.error("No active game or no cells revealed");
      return;
    }

    try {
      let result;
      try {
        result = await mines.cashOut();
      } catch (cashOutError) {
        console.error("‚ùå Error cashing out with backend:", cashOutError);

        // Mock cashout logic for testing without backend
        console.log("üìù Using mock cashout logic for testing");

        // Calculate a mock win amount based on the current bet and multiplier
        const betAmountE8s = gameState ? BigInt(gameState.bet_amount) : 0n;
        const winAmountE8s =
          (betAmountE8s * BigInt(Math.floor(multiplier * 100))) / 100n;

        // Clone the current game state and update it
        const mockGameState = JSON.parse(JSON.stringify(gameState));
        mockGameState.game_status = { Completed: true };
        mockGameState.win_amount = winAmountE8s.toString();

        // If we don't have mine positions yet, generate them deterministically
        if (
          !mockGameState.mine_positions ||
          !mockGameState.mine_positions.length
        ) {
          mockGameState.mine_positions = [];
          // Add deterministic mines, making sure they don't overlap with revealed cells
          const totalMines = Math.min(minesCount, 24); // Max 24 mines

          // Use a deterministic seed based on the game session
          const timestamp = new Date().getTime();
          const deterministicSeed = timestamp + safeNumber(gameState.betAmount);

          // Iterate through all cells and use a deterministic formula to select mines
          for (
            let i = 0;
            i < 25 && mockGameState.mine_positions.length < totalMines;
            i++
          ) {
            // Cell is a mine if (position + seed) mod 5 equals 2 and it's not already revealed
            const isMine = (i + deterministicSeed) % 5 === 2;

            // Don't put mines in revealed cells
            if (
              isMine &&
              !mockGameState.revealed_cells.includes(i) &&
              !mockGameState.mine_positions.includes(i)
            ) {
              mockGameState.mine_positions.push(i);
            }
          }
        }

        result = mockGameState;
        console.log("üí∞ Mock cashout result:", result);
      }

      if (result) {
        // Update states based on backend response
        setIsPlaying(false);
        setGameWon(true);
        setShowConfetti(true);

        // Properly convert from e8s to APTC with precise handling
        const winAmountE8s = BigInt(result.win_amount);
        const winAmount = formatTokenAmount(winAmountE8s); // Convert from e8s to APTC

        // Format with exact 2 decimal places for display
        const formattedWinAmount = winAmount.toFixed(2);

        toast.success(
          `Cashed out! Payout: ${formattedWinAmount} APTC at ${multiplier}x`
        );
        playSound("cashout");

        // Log exact payout amount for verification
        console.log("üí∞ MINES GAME - Cashout:", {
          originalBet: settings.betAmount,
          winAmountE8s: winAmountE8s.toString(),
          winAmountDecimal: winAmount,
          formattedForUI: formattedWinAmount + " APTC",
          multiplier: multiplier,
        });

        // Dispatch game result event for token balance updates with proper bet details
        window.dispatchEvent(
          new CustomEvent("gameResult", {
            detail: {
              game: "mines",
              result: "win",
              bet: settings.betAmount, // Original bet amount
              betE8s: parseTokenAmount(settings.betAmount).toString(), // Original bet in e8s
              payout: winAmount, // Human-readable payout amount
              payoutE8s: winAmountE8s.toString(), // E8s payout for precise calculations
              formattedPayout: formattedWinAmount, // Formatted for UI display
              multiplier: multiplier,
            },
          })
        );

        // Ensure token balance is refreshed - wait a moment for transaction to complete
        setTimeout(() => {
          if (typeof window.refreshTokenBalance === "function") {
            window.refreshTokenBalance(true); // Force refresh
          }
        }, 800); // Longer delay to ensure transaction completes

        // Refresh grid to show the final state
        if (result.mine_positions && result.mine_positions.length > 0) {
          const newGrid = [...grid];
          // Mark revealed cells as diamonds
          result.revealed_cells.forEach((cellIndex) => {
            const row = Math.floor(cellIndex / gridSize);
            const col = cellIndex % gridSize;
            if (row < gridSize && col < gridSize) {
              newGrid[row][col].isRevealed = true;
              newGrid[row][col].isDiamond = true;
            }
          });

          // Mark mine positions but don't reveal them
          result.mine_positions.forEach((cellIndex) => {
            const row = Math.floor(cellIndex / gridSize);
            const col = cellIndex % gridSize;
            if (row < gridSize && col < gridSize) {
              newGrid[row][col].isBomb = true;
            }
          });

          setGrid(newGrid);
        }

        setTimeout(() => setShowConfetti(false), 5000);
      }
    } catch (err) {
      console.error("Cashout error:", err);
      toast.error(err.message || "Failed to cash out");
    }
  }, [
    isPlaying,
    revealedCount,
    mines,
    multiplier,
    grid,
    gridSize,
    gameState,
    minesCount,
  ]);

  // Toggle mute
  const toggleMute = () => {
    setIsMuted(!isMuted);
  };

  // Toggle game info
  const toggleGameInfo = () => {
    setIsGameInfoVisible(!isGameInfoVisible);
  };

  const adjustMinesCount = (delta) => {
    if (isPlaying) return;

    // For 5x5 grid, allow up to 24 mines (with 1 safe tile)
    const newCount = Math.max(1, Math.min(minesCount + delta, 24));
    setMinesCount(newCount);
  };

  // Show connection status
  const renderConnectionStatus = () => {
    if (loading.actors) {
      return (
        <div className="text-center text-yellow-400 mb-4">
          Connecting to backend...
        </div>
      );
    }

    if (!isConnected || !walletPrincipal) {
      return (
        <div className="text-center text-red-400 mb-4">
          Please connect your wallet to play
        </div>
      );
    }

    if (error) {
      return (
        <div className="text-center text-red-400 mb-4">Error: {error}</div>
      );
    }

    return null;
  };

  // Cell content renderer
  const getCellContent = (cell) => {
    if (!cell.isRevealed) {
      return (
        <div className="w-full h-full flex items-center justify-center">
          <FaQuestion className="text-gray-400 text-xl md:text-2xl" />
        </div>
      );
    }

    if (cell.isBomb) {
      return (
        <div className="w-full h-full flex items-center justify-center">
          <img
            src={MINE_SPRITES[cell.spriteIndex % MINE_SPRITES.length]}
            alt="Mine"
            width={64}
            height={64}
            className="w-10 h-10 md:w-12 md:h-12 object-contain"
          />
        </div>
      );
    }

    if (cell.isDiamond) {
      return (
        <div className="w-full h-full flex items-center justify-center">
          <img
            src={GEM_SPRITES[cell.spriteIndex % GEM_SPRITES.length]}
            alt="Gem"
            width={64}
            height={64}
            className="w-10 h-10 md:w-12 md:h-12 object-contain"
          />
        </div>
      );
    }

    return null;
  };

  return (
    <div className="relative flex flex-col items-center w-full">
      {/* Audio elements */}
      {Object.entries(SOUNDS).map(([key, src]) => (
        <audio key={key} ref={audioRefs[key]} src={src} preload="auto" />
      ))}

      {/* Confetti animation for wins */}
      {showConfetti && (
        <Confetti
          width={width}
          height={height}
          recycle={false}
          numberOfPieces={300}
        />
      )}

      {/* Connection status */}
      {renderConnectionStatus()}

      {/* Toast notifications */}
      <ToastContainer
        position="top-right"
        autoClose={3000}
        hideProgressBar={false}
        closeOnClick
        pauseOnHover
        theme="dark"
      />

      {/* Game information overlay */}
      <AnimatePresence>
        {isGameInfoVisible && (
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 20 }}
            className="absolute top-0 left-0 right-0 bottom-0 bg-black/90 backdrop-blur-sm z-50 p-6 overflow-auto"
          >
            <div className="max-w-2xl mx-auto">
              <h3 className="text-2xl font-bold text-white mb-4 flex items-center">
                <GiMineTruck className="mr-2 text-red-500" /> How to Play Mines
              </h3>

              <div className="space-y-4 text-white/90">
                <p>
                  <strong>Objective:</strong> Reveal gem tiles while avoiding
                  hidden mines.
                </p>

                <div className="flex items-center gap-2 bg-gray-800/50 p-2 rounded">
                  <FaRegGem className="text-blue-400 text-xl" />
                  <span>
                    Gems are safe to click - each one increases your multiplier.
                  </span>
                </div>

                <div className="flex items-center gap-2 bg-gray-800/50 p-2 rounded">
                  <FaBomb className="text-red-500 text-xl" />
                  <span>
                    Mines end your game if clicked - you lose your bet.
                  </span>
                </div>

                <div className="flex items-center gap-2 bg-gray-800/50 p-2 rounded">
                  <FaCoins className="text-yellow-500 text-xl" />
                  <span>Cashout anytime to secure your winnings.</span>
                </div>

                <p>
                  <strong>Strategy:</strong> More mines mean higher risk but
                  bigger potential rewards.
                </p>

                <div className="border border-gray-700 rounded p-4">
                  <h4 className="text-lg font-semibold mb-2">Payout Formula</h4>
                  <p className="font-mono bg-gray-800/50 p-2 rounded text-sm">
                    multiplier = totalTiles / (totalTiles - mines -
                    revealedTiles)
                  </p>
                </div>
              </div>

              <button
                className="mt-6 px-4 py-2 bg-gradient-to-r from-purple-600 to-blue-600 rounded-lg text-white font-medium"
                onClick={toggleGameInfo}
              >
                Got it!
              </button>
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Game Header */}
      <div className="w-full flex flex-wrap justify-between items-center gap-2 mb-4">
        <div className="flex items-center space-x-3">
          <button
            className="p-2 rounded-full bg-purple-900/20 hover:bg-purple-900/40 transition-colors"
            onClick={toggleMute}
            title={isMuted ? "Unmute" : "Mute"}
          >
            {isMuted ? (
              <HiOutlineVolumeOff className="text-white/70 text-xl" />
            ) : (
              <HiOutlineVolumeUp className="text-white/70 text-xl" />
            )}
          </button>

          <button
            className="p-2 rounded-full bg-blue-900/20 hover:bg-blue-900/40 transition-colors"
            onClick={toggleGameInfo}
            title="Game Info"
          >
            <HiOutlineInformationCircle className="text-white/70 text-xl" />
          </button>
        </div>

        <div className="flex items-center">
          <div className="text-sm text-white/70 mr-2">Mines:</div>
          <div className="flex items-center bg-gray-900/50 rounded overflow-hidden">
            <button
              className="px-2 py-1 bg-red-900/30 hover:bg-red-900/50 text-white disabled:opacity-50"
              onClick={() => adjustMinesCount(-1)}
              disabled={isPlaying || minesCount <= 1}
            >
              -
            </button>
            <div className="px-3 py-1 font-medium text-white">{minesCount}</div>
            <button
              className="px-2 py-1 bg-green-900/30 hover:bg-green-900/50 text-white disabled:opacity-50"
              onClick={() => adjustMinesCount(1)}
              disabled={isPlaying || minesCount >= 24}
            >
              +
            </button>
          </div>
        </div>
      </div>

      {/* Game Stats */}
      <div className="w-full grid grid-cols-3 gap-2 mb-3">
        <div className="bg-gray-900/50 rounded p-2 text-center">
          <div className="text-xs text-white/50 mb-1">Chance of Mine</div>
          <div
            className={`text-lg font-bold ${
              calculateMineChance() > 50 ? "text-red-400" : "text-white"
            }`}
          >
            {calculateMineChance()}%
          </div>
        </div>

        <div className="bg-gray-900/50 rounded p-2 text-center">
          <div className="text-xs text-white/50 mb-1">Multiplier</div>
          <div className="text-lg font-bold text-yellow-400">
            {multiplier.toFixed(2)}x
          </div>
        </div>

        <div className="bg-gray-900/50 rounded p-2 text-center">
          <div className="text-xs text-white/50 mb-1">Profit</div>
          <div
            className={`text-lg font-bold ${
              profit > 0 ? "text-green-400" : "text-white"
            }`}
          >
            {profit > 0 ? "+" : ""}
            {profit}
          </div>
        </div>
      </div>

      {/* Game Grid */}
      <div
        className={`grid gap-1.5 w-full mb-3 mx-auto max-w-md`}
        style={{
          gridTemplateColumns: `repeat(${gridSize}, minmax(0, 1fr))`,
        }}
      >
        {grid.map((row, rowIndex) =>
          row.map((cell, colIndex) => (
            <motion.button
              key={`${rowIndex}-${colIndex}`}
              className={`
                aspect-square flex items-center justify-center rounded-lg 
                ${
                  cell.isRevealed
                    ? cell.isBomb
                      ? "bg-red-900/70"
                      : "bg-blue-600/30"
                    : cell.isHovered
                    ? "bg-purple-800/30"
                    : "bg-gray-900/70"
                }
                ${
                  !isPlaying
                    ? "cursor-not-allowed opacity-80"
                    : "cursor-pointer"
                }
                ${cell.isRevealed ? "" : "hover:bg-purple-800/30"}
                transition-colors duration-200 text-2xl
                border border-gray-800 shadow-lg
              `}
              onClick={() => isPlaying && revealCell(rowIndex, colIndex)}
              onMouseEnter={() => handleCellHover(rowIndex, colIndex, true)}
              onMouseLeave={() => handleCellHover(rowIndex, colIndex, false)}
              disabled={
                !isPlaying ||
                cell.isRevealed ||
                gameOver ||
                gameWon ||
                loading.mines
              }
              whileHover={{
                scale:
                  isPlaying && !cell.isRevealed && !loading.mines ? 1.05 : 1,
              }}
              whileTap={{
                scale:
                  isPlaying && !cell.isRevealed && !loading.mines ? 0.95 : 1,
              }}
              animate={{
                opacity: cell.isRevealed ? 1 : 0.9,
                scale: cell.isRevealed ? 1 : 1,
              }}
              transition={{ type: "spring", stiffness: 400, damping: 17 }}
            >
              {getCellContent(cell)}
            </motion.button>
          ))
        )}
      </div>

      {/* Game Controls */}
      <div className="w-full space-y-2">
        {/* Betting Form - Show when no bet has been placed */}
        {!hasPlacedBet && isConnected && walletPrincipal && (
          <div className="mb-4">
            {/* Balance Display */}
            <div className="bg-gradient-to-r from-purple-900/30 to-blue-900/30 p-3 rounded-lg mb-4 border border-purple-800/20">
              <div className="flex items-center justify-between">
                <span className="text-white/70 text-sm">Your Balance:</span>
                <span className="text-white font-bold text-lg flex items-center">
                  <FaCoins className="text-yellow-400 mr-2" />
                  {aptcBalance.toLocaleString()} APTC
                </span>
              </div>
            </div>

            {/* Betting Interface */}
            <SimpleBetting
              onSubmit={(settings) => {
                setBetAmount(settings.betAmount);
                setMinesCount(settings.mines);
                startNewGame(settings.betAmount, settings.mines);
              }}
              initialSettings={{ betAmount, mines: minesCount }}
            />
          </div>
        )}

        {hasPlacedBet && (
          <div className="flex gap-3">
            <button
              onClick={cashout}
              disabled={!isPlaying || revealedCount === 0}
              className={`flex-1 py-3 ${
                isPlaying && revealedCount > 0
                  ? "bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700"
                  : "bg-gray-700 cursor-not-allowed"
              } rounded-lg text-white font-bold shadow-lg transition-all flex items-center justify-center gap-2`}
            >
              <FaCoins className="text-yellow-300" />
              <span>CASH OUT ({calculatePayout()} APTC)</span>
            </button>

            <button
              onClick={() => {
                resetGame();
                setHasPlacedBet(false); // Allow user to go back to the form
              }}
              className="flex-1 py-3 bg-gradient-to-r from-red-600 to-orange-600 rounded-lg text-white font-bold shadow-lg hover:from-red-700 hover:to-orange-700 transition-all flex items-center justify-center gap-2"
            >
              <FaDice className="text-white" />
              <span>NEW GAME</span>
            </button>
          </div>
        )}

        {/* Game result message */}
        {(gameOver || gameWon) && (
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            className={`text-center py-1.5 rounded-lg ${
              gameWon
                ? "bg-green-900/30 text-green-400"
                : "bg-red-900/30 text-red-400"
            } font-bold`}
          >
            {gameWon
              ? "Congratulations! You won!"
              : "Game Over! You hit a mine!"}
          </motion.div>
        )}
      </div>

      {/* Multiplier Table */}
      <div className="w-full mt-2">
        <h3 className="text-white font-medium mb-2 flex items-center">
          <GiCrystalGrowth className="mr-2 text-blue-400" />
          Multiplier Table
        </h3>
        <div className="relative">
          {/* Scrollable multiplier table with improved styling and indicators */}
          <div className="bg-black/40 p-4 rounded-xl border border-gray-700/60 shadow-lg">
            {/* Shadow indicators with arrow icons for better UX */}
            <div className="absolute left-0 top-0 bottom-0 w-10 bg-gradient-to-r from-black to-transparent z-10 pointer-events-none flex items-center justify-center">
              <FaArrowLeft className="text-purple-400 ml-2" />
            </div>
            <div className="absolute right-0 top-0 bottom-0 w-10 bg-gradient-to-l from-black to-transparent z-10 pointer-events-none flex items-center justify-center">
              <FaArrowRight className="text-purple-400 mr-2" />
            </div>

            <div className="overflow-x-auto pb-1">
              <div className="flex gap-3 min-w-max">
                {multiplierTable.map((item, index) => (
                  <div
                    key={index}
                    className={`min-w-[95px] p-2.5 text-center rounded-lg ${
                      item.tiles === revealedCount
                        ? "bg-gradient-to-br from-purple-700 to-purple-600 text-white font-bold shadow-lg shadow-purple-700/50 border-2 border-purple-500/80"
                        : "bg-gradient-to-br from-gray-800/90 to-gray-900/90 text-white/90 hover:bg-gray-700/90 transition-colors shadow-md border border-gray-700/50"
                    }`}
                  >
                    <div className="text-xs font-medium mb-1">
                      {item.tiles} Tiles
                    </div>
                    <div className="text-xl font-semibold">
                      {item.multiplier.toFixed(2)}x
                    </div>
                  </div>
                ))}
              </div>
            </div>

            {safeTiles === 1 ? (
              <div className="text-xs text-center text-yellow-400 font-medium mt-3">
                Only 1 safe tile with a 25.00x multiplier!
              </div>
            ) : (
              multiplierTable.length > 6 && (
                <div className="text-xs text-center text-white/80 mt-3 flex items-center justify-center gap-2">
                  <FaArrowLeft className="text-purple-400" />
                  <span>Swipe to see more multipliers</span>
                  <FaArrowRight className="text-purple-400" />
                </div>
              )
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

export default Game;
